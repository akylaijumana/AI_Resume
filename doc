# Project Requirements — Final Project (Software Engineering)
**Date:** 2025-12-13

---

## Purpose

This document summarizes concise, English-language requirements for the final project in the "Software Engineering" course. It defines goals, mandatory deliverables, the required Software Requirements Specification (SRS) contents, minimum MVP scope, repository expectations, and acceptance conditions.

---

## 1. Project Goal

Students must develop a real, working software product that could be used beyond the classroom. Acceptable project types include business applications, automation systems, AI-enabled services, web or mobile apps, and solutions that address real operational problems. The project must be an engineering effort, not a trivial tutorial.

---

## 2. Mandatory Deliverables

### 2.1 Technical Specification (SRS)

The SRS must follow common standards (e.g., IEEE 830/29148) and contain at least the items below:

- Introduction: purpose, scope, definitions.
- Problem statement: what problem the project solves and the target users.
- Goals and objectives: what the system must achieve and the business value.
- System requirements: functional and non-functional (performance, security, reliability, UX, compatibility), constraints, and assumptions.
- Architecture: high-level architecture and component interactions.
- Database: chosen DBMS, schema/ER diagram, storage and access rules.
- Interface: main screens/endpoints, user roles, UI behavior.
- Testing: test types required, acceptance criteria.
- Deployment (optional): installation and environment notes.
- MVP readiness: list of mandatory features for the minimal demonstration.

### 2.2 Project Roadmap (recommended)

A short development plan using Agile/Scrum or Kanban. Include a roadmap, prioritized backlog (MoSCoW or value/effort), and key risks with mitigation strategies.

---

## 3. MVP Requirements (required)

The MVP must include working client, server, and database components appropriate to the project type.

### 3.1 Client

- Implement at least 1–2 core user scenarios (web, mobile, or desktop).
- Integrate with the server API. Authentication is recommended where relevant.

### 3.2 Server

- Provide an API (REST or GraphQL) implementing business logic and data access.
- Secure the API (token/JWT/session or appropriate scheme).

### 3.3 Database

- Use a reasonable DBMS (Postgres, MySQL, SQLite, MongoDB, etc.).
- Provide a schema and implement basic CRUD operations.

### 3.4 Architecture and Testing

- Separate client and server with clear configuration files and error handling.
- Provide API documentation (OpenAPI/Swagger recommended).
- Include unit tests for key logic and basic integration/API tests.

---

## 4. Repository Requirements (GitHub)

- Recommended structure: `/client`, `/server`, `/docs` (including SRS and roadmap).
- `README.md` must include project description, stack, installation and run instructions, and sample API calls.
- Code must be complete and runnable; avoid missing dependencies or private components.
- Use meaningful commit messages and branches (recommended but not mandatory).

---

## 5. Grading / Acceptance Criteria

To pass, submit the following:

- A complete SRS (see Section 2.1).
- A working MVP with client, server, and database.
- The project hosted in a GitHub repository with a clear README.
- A short demo (recorded video or live) and readiness to answer questions on architecture and implementation.

Evaluation will check:

- Functional correctness of MVP features.
- Code quality and project structure.
- Presence of tests and basic test results.
- Documentation completeness (SRS + README + API docs).
- Ability to explain design choices and trade-offs.

---

## 6. Minimal submission checklist (copy into your repo `docs/` or README)

- [ ] SRS document (SRS.md or doc/SRS)
- [ ] Roadmap / backlog (optional but recommended)
- [ ] Client code (or UI demo)
- [ ] Server code and API (with docs)
- [ ] Database schema and seed/test data
- [ ] Unit tests and instructions to run them
- [ ] README with run/install instructions
- [ ] Demo link or recorded video

---

## Notes and good practices

- Keep the SRS concise, clear, and in English. Don't overdo details — include what's necessary for reproducibility and assessment.
- Use OpenAPI/Swagger for API clarity if you have a server component.
- Prefer automated tests for core logic. Manual UI tests are acceptable for heavy UI components.
- If your project uses external services or paid APIs, document them clearly and provide fallback modes or test keys.

---

If you want, I can:

- Convert this into a nicely formatted `SRS.md` and place it under `docs/` and `doc/`.
- Generate a short README template, a simple OpenAPI stub, or a basic test skeleton for the project.

Tell me which of these you'd like next.

---